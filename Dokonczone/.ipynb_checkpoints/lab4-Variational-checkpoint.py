# -*- coding: utf-8 -*-
"""Variational.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/KOS-UJ/Numerical-PDEs/blob/master/Variational.ipynb

# Numeryczne rozwiązywanie równań różniczkowych cząstkowych
## Równanie eliptyczne

<br>


### Metoda Galerkina 2D
"""

import numpy as np
import pylab
from mpl_toolkits.mplot3d import Axes3D
import matplotlib.pyplot as plt
from matplotlib import cm
from matplotlib.ticker import LinearLocator, FormatStrFormatter

"""Użyjemy sympy, by nie musieć samodzielnie liczyć całek."""

import sympy as sp
from sympy import symbols, sqrt, exp, diff, integrate, pprint  

x, y = sp.symbols('x y')
                                                                                                                                                              

# pprint(diff(4*x**3+exp(3*x**2*y)+y**2,x))                                                                                                                                          
# pprint(diff(4*x**3+exp(3*x**2*y)+y**2,y))                                                                                                                                          
# pprint(integrate(exp(x*y**2)+sqrt(x)*y**2,x))                                                                                                                                      
# pprint(integrate(exp(x*y**2)+sqrt(x)*y**2,y))

_I = integrate(exp(x*y**2)+sqrt(x)*y**2, (x,0,1), (y,-1,1))
pprint(_I)
print(_I)
print(np.array(_I).astype(np.float64))

"""Zacznijmy od fukcji bazowych dla metody Galerkina

Proszę zaimplementować funkcja zwracająca funkcje bazowe postaci

$$ sin(i \pi x) sin (j \pi y)$$
"""

def sines(x, y, Nx, Ny):
    pass  # TODO

"""Równanie Poissona:

$$ -\Delta u = f \;\;\; \text{w} \;\;\; \Omega $$
$$ u = 0 \;\;\; \text{na} \;\;\; \partial \Omega $$

Zbudujmy odpowiedni układ równań


$$\sum\limits_{j=1}^{n} c_j \iint_\Omega \nabla \psi_j \nabla \psi_i dxdy = \iint_\Omega f \psi_i dxdy \;\;\; i=1,...,n$$


$$ Ac = b $$

Zaimplementujmy tworzenie takiego układu równań: 
"""

def construct_A_and_b(f, psi, Omega):
    N = len(psi)
    A = sp.zeros(N, N)
    b = sp.zeros(N, 1)
    for i in range(N):
        for j in range(i, N):
            # TODO
            A[i, j] = A[j, i] = I

        # TODO
        b[i, 0] = I
    return A, b

"""### Zadanie 1"""

f = 0
psi = sines(x, y, 1, 1)
Omega = [[0, 1], [0, 1]]
A, b = construct_A_and_b(f, psi, Omega)
# print(A, b)
pprint(A)
pprint(b)

"""Rozwiązanie symobliczne"""

c = A.LUsolve(b)
u = 0
for i in range(len(psi)):
    u += c[i, 0] * psi[i]
print(u)

"""Rozwiązanie numeryczne"""

A = np.array(A).astype(np.float64)
b = np.array(b).astype(np.float64)
c = np.linalg.solve(A, b)

"""Pomocnicze funkcje to wyrysowania wyników"""

def scatter_solution(c, psi, Omega, psi_0=0*x*y, d=32):
    X, Y, u = np.linspace(Omega[0][0], Omega[0][1], d), np.linspace(Omega[1][0], Omega[1][1], d), np.zeros((d, d))
    for i, x_value in enumerate(X):
        for j, y_value in enumerate(Y):
            u[i, j] = psi_0.subs([(x, x_value), (y, y_value)])
            for k in range(len(psi)):
                u[i, j] += float(c[k] * psi[k].subs([(x, x_value), (y, y_value)]))
    return X, Y, u

def scatter_exac(func, Omega, d=32):
    X, Y, u = np.linspace(Omega[0][0], Omega[0][1], d), np.linspace(Omega[1][0], Omega[1][1], d), np.zeros((d, d))
    for i, x_value in enumerate(X):
        for j, y_value in enumerate(Y):
            u[i, j] = func.subs([(x, x_value), (y, y_value)])
    return X, Y, u

def plot_surface(X, Y, u):
    fig = plt.figure()
    ax = fig.gca(projection='3d')

    # Prepare grid.
    X, Y = np.meshgrid(X, Y)

    # Plot the surface.
    surf = ax.plot_surface(X, Y, u, cmap=cm.coolwarm,
                           linewidth=0, antialiased=False)

    # Customize the z axis.
    # ax.set_zlim(-.2, 1.2)
    ax.zaxis.set_major_locator(LinearLocator(10))
    ax.zaxis.set_major_formatter(FormatStrFormatter('%.02f'))

    # Add a color bar which maps values to colors.
    fig.colorbar(surf, shrink=0.5, aspect=5)

    plt.show()

plot_surface(*scatter_solution(c, psi, Omega))
plot_surface(*scatter_exac(0*x*y, Omega))

"""### Zadanie 2

$$ -\Delta u = - 2  \pi^2  \sin(\pi  x) \sin(\pi y) \;\;\; \text{w} \;\;\; \Omega $$
$$ u = 0 \;\;\; \text{na} \;\;\; \partial \Omega $$
"""

f = # TODO
psi = sines(x, y, 1, 1)
Omega = [[0, 1], [0, 1]]
A, b = construct_A_and_b(f, psi, Omega)
# print(A, b)

A = np.array(A).astype(np.float64)
b = np.array(b).astype(np.float64)
c = np.linalg.solve(A, b)

plot_surface(*scatter_solution(c, psi, Omega))
plot_surface(*scatter_exac(sp.sin(sp.pi * x) * sp.sin(sp.pi * y), Omega))

"""### Zadanie 3
Rozważmy zagadnienie z niezerowym brzegiem:
$$ -\Delta u = 0 $$
$$ \Omega = (0, a) \text{x} (0, a) $$

$$ u(0, y) = 0 $$
$$ u(a, y) = u_0(e^y - 1) $$
$$ u(x, 0) = 0 $$
$$ u(x, a) = u_0(e^x - 1) $$

Będziemy szukać funkcji postaci:

$$ u_{i}(x, y) = \psi_0 (x, y) + \sum\limits_{j=1}^{n} c_j \psi_j (x, y) $$

Proponuję:

$$ \psi_0 (x, y) = u_0 \frac{(e^x - 1)(e^y - 1)}{e^a - 1} $$


Rozwiąż dla $a = 3$
"""

def construct_A_and_b_with_psi_0(f, psi, psi_0, Omega):
    pass  # TODO

f = 0
psi = sines(x, y, 1, 1)
a = 3
Omega = [[0, a], [0, a]]
psi_0 = # TODO

A, b = construct_A_and_b_with_psi_0(f, psi, psi_0, Omega)

"""Rozwiązanie symboliczne jest dość skomplikowane"""

c = A.LUsolve(b)
u = psi_0
for i in range(len(psi)):
    u += c[i, 0] * psi[i]
print(u)
# pprint(u)

A = np.array(A).astype(np.float64)
b = np.array(b).astype(np.float64)
c = np.linalg.solve(A, b)

plot_surface(*scatter_solution(c, psi, Omega, psi_0))

"""### Zadanie 4

$$ -\Delta u = \sin(\pi y) (4 \pi x \cos(\pi  x) -
    (\pi^2 (x^2 + y^2)-2) \sin(\pi x)) + 
    \sin(\pi  x) (4 \pi y \cos(\pi y) -
    (\pi^2  (x^2 + y^2) - 2)  \sin(\pi y)) \;\;\; \text{w} \;\;\; \Omega $$
$$ u = 0 \;\;\; \text{na} \;\;\; \partial \Omega $$

Srawdź błąd względny metody, co należy zmienić, aby się zmiejszył?
"""

f = sp.sin(sp.pi * y) * (4 * sp.pi * x *sp.cos(sp.pi * x) -\
    (sp.pi**2 * (x**2 + y**2) - 2) * sp.sin(sp.pi * x)) + \
    sp.sin(sp.pi * x) * (4 * sp.pi * y *sp.cos(sp.pi * y) -\
    (sp.pi**2 * (x**2 + y**2) - 2) * sp.sin(sp.pi * y))
psi = sines(x, y, 1, 1)
Omega = [[0, 1], [0, 1]]
A, b = construct_A_and_b(f, psi, Omega)

A = np.array(A).astype(np.float64)
b = np.array(b).astype(np.float64)
c = np.linalg.solve(A, b)

plot_surface(*scatter_solution(c, psi, Omega))
plot_surface(*scatter_exac(sp.sin(sp.pi * x) * sp.sin(sp.pi * y) * (x**2 + y**2), Omega))

# ???

"""### Zadanie 5

$$ -\Delta u = 2 (x^2 + y^2) - 2 \pi ^ 2 \sin(\pi x) \sin(\pi y) \;\;\; \text{w} \;\;\; \Omega $$
$$ \Omega = (0, a) \text{x} (0, a) $$

$$ u(0, y) = 0 $$
$$ u(a, y) = y^2 $$
$$ u(x, 0) = 0 $$
$$ u(x, a) = x^2 $$
"""

f =  # TODO
psi = sines(x, y, 1, 1)
Omega = [[0, 1], [0, 1]]
psi_0 =  # TODO

A, b = construct_A_and_b_with_psi_0(f, psi, psi_0, Omega)

A = np.array(A).astype(np.float64)
b = np.array(b).astype(np.float64)
c = np.linalg.solve(A, b)

plot_surface(*scatter_solution(c, psi, Omega, psi_0))
plot_surface(*scatter_exac(x**2 * y**2 + sp.sin(sp.pi * x) * sp.sin(sp.pi * y), Omega))

"""### Metoda różnic skończonych
Zaimplementuj metodę różnic skończonych, rozwiąż powyższe zadania i porównaj wyniki
"""



"""### Zadanie 6*: 
$ -\Delta u = -3 \pi^2 \sin(\pi x) \sin(\pi y) \sin(\pi z)$


$ u = 0 \;\;\; \text{na} \;\;\; \partial \Omega $


$ \Omega = (0, 1) \text{x} (0, 1) \text{x} (0, 1)$

Rozwiązadnie dokładne:
$\sin(\pi x) \sin(\pi y) \sin(\pi z)$
"""

